"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ts_exports = {};
__export(ts_exports, {
  getGraph: () => getGraph,
  getManifestsPaths: () => getManifestsPaths,
  getPackages: () => getPackages,
  getRootPackage: () => getRootPackage,
  slash: () => slash,
  topo: () => topo
});
module.exports = __toCommonJS(ts_exports);
var import_toposort = __toESM(require("toposort"), 1);
var import_fast_glob = __toESM(require("fast-glob"), 1);
var import_path = require("path");
var import_fs = require("fs");
const readJsonFile = async (filepath) => JSON.parse(await import_fs.promises.readFile(filepath, "utf8"));
const getPackages = async (options) => {
  const filter = options.filter || ((_) => true);
  const manifestsPaths = await getManifestsPaths(options);
  const manifests = await Promise.all(
    manifestsPaths.map((p) => readJsonFile(p))
  );
  checkDuplicates(manifests);
  return manifests.reduce((m, p, i) => {
    const absPath = (0, import_path.dirname)(manifestsPaths[i]);
    const relPath = (0, import_path.relative)(options.cwd, absPath);
    const entry = {
      name: p.name,
      manifest: p,
      manifestPath: manifestsPaths[i],
      path: relPath,
      relPath,
      absPath
    };
    if (filter(entry)) {
      m[p.name] = entry;
    }
    return m;
  }, {});
};
const checkDuplicates = (manifests) => {
  const duplicates = manifests.map((m) => m.name).filter((e, i, a) => a.indexOf(e) !== i);
  if (duplicates.length > 0) {
    throw new Error(`Duplicated pkg names: ${duplicates.join(", ")}`);
  }
};
const getRootPackage = async (cwd) => {
  const manifestPath = (0, import_path.resolve)(cwd, "package.json");
  const manifest = await readJsonFile(manifestPath);
  return {
    name: manifest.name,
    manifest,
    manifestPath,
    path: "/",
    relPath: "/",
    absPath: (0, import_path.dirname)(manifestPath)
  };
};
const topo = async (options = {}) => {
  const { cwd = process.cwd(), filter = (_) => true } = options;
  const root = await getRootPackage(cwd);
  const _options = {
    cwd,
    filter,
    workspaces: options.workspaces || root.manifest.workspaces || []
  };
  const packages = await getPackages(_options);
  const { edges, nodes } = getGraph(
    Object.values(packages).map((p) => p.manifest)
  );
  const queue = import_toposort.default.array(nodes, edges);
  return {
    queue,
    packages,
    edges,
    nodes,
    root
  };
};
const getGraph = (manifests) => {
  const nodes = manifests.map(({ name }) => name).sort();
  const edges = manifests.reduce((edges2, pkg) => {
    Object.keys({
      ...pkg.dependencies,
      ...pkg.devDependencies,
      ...pkg.optionalDependencies,
      ...pkg.peerDependencies
    }).forEach(
      (_name) => nodes.includes(_name) && edges2.push([_name, pkg.name])
    );
    return edges2;
  }, []).sort();
  return {
    edges,
    nodes
  };
};
const getManifestsPaths = async ({
  workspaces,
  cwd
}) => await (0, import_fast_glob.default)(
  workspaces.map((w) => slash((0, import_path.join)(w, "package.json"))),
  {
    cwd,
    onlyFiles: true,
    absolute: true
  }
);
const slash = (path) => {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path);
  if (isExtendedLengthPath || hasNonAscii) {
    return path;
  }
  return path.replace(/\\/g, "/");
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getGraph,
  getManifestsPaths,
  getPackages,
  getRootPackage,
  slash,
  topo
});
